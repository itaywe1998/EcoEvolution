
R version 3.6.3 (2020-02-29) -- "Holding the Windsock"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # Copyright (C) 2021 György Barabás ----
> # This program comes with ABSOLUTELY NO WARRANTY. This is free software, and
> # you are welcome to redistribute it under certain conditions. for details,
> # see the GNU General Public License Agreement (in the file COPYING.txt).
> 
> # To run, either execute within R or enter the following at the command prompt:
> # Rscript ecoevo.R [vbar] [dbar] [model] [replicate] [outfile]---- 
> 
> rm(list = ls())
> start <- Sys.time()
> require(gridExtra)
Loading required package: gridExtra
> require(deSolve) # solving ordinary differential equations (ODEs)
Loading required package: deSolve
> require(tidyverse) # manipulating and visualizing data
Loading required package: tidyverse
Warning message:
In library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘tidyverse’
> require(ggpmisc) # adding statistics to plots
Loading required package: ggpmisc
Warning message:
In library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘ggpmisc’
> require(Rcpp) # importing C functions
Loading required package: Rcpp
> library(tidyr)
> library(dplyr)

Attaching package: ‘dplyr’

The following object is masked from ‘package:gridExtra’:

    combine

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> library(ggplot2)
> library(readr)
> sourceCpp("rhs_eval.cpp") # compile external C functions
> source("./plotting_functions.R") # various functions for plotting final data
Loading required package: tidyverse
Loading required package: ggpmisc
Warning messages:
1: In library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘tidyverse’
2: In library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
  there is no package called ‘ggpmisc’
> 
> # ---------------------------- input parameters --------------------------------
> clargs <- commandArgs(trailingOnly=TRUE)
> if (length(clargs)>0) { # command-line arguments
+   S <- as.numeric(clargs[1]) # number of species per trophic level
+   vbar <- as.numeric(clargs[2]) # mean genetic variance
+   dbar <- as.numeric(clargs[3]) # mean dispersal rate
+   model <- clargs[4] # "baseline", "trophic", "Tdep", or "Tdep_trophic"
+   small <- as.logical(clargs[5]) # true for short adaptation time, false for long
+   replicate <- as.numeric(clargs[6]) # for seeding random number generator
+   outfile <- clargs[7] # name of file to save data in (w/ path & extension)
+   workspace <- clargs[8] # path to save configuration in
+ } else { # sample input parameters, if no command line arguments are given
+   S <- 10 # fifty species per trophic level
+   vbar <- 6e-3  # average genetic variance = 0.1 celsius squared
+   dbar <- 6e-3  # average dispersal = 1e-5 (100 meters per year)
+   model <- "baseline" # 2 trophic levels & temperature-dependent competition
+   replicate <- 1 # replicate number = 1
+   small <-FALSE
+   id <-"debugT"
+   if (small){
+     ts<--1e6
+     str<-"small"
+   }
+   else {
+     ts<--1e8
+     str<-"large"
+   }
+   file <- paste(str,"_time_v",toString(format(vbar, scientific = TRUE)),"_d",toString(dbar),"id",toString(id),sep ="")
+   outfile <- paste("outputs/",file, sep = "") # no output file; make plot instead
+   workspace <-paste("parameters/",file, sep="")
+   }
> 
> 
> # --------------------------------functions ------------------------------------
> 
> # return matrix W[i,j], which is nonzero if consumer i eats resource j;
> # SR is the number of resource, SC the number of consumer species
> generate_network <- function(SR, SC) {
+   w <- matrix(0, SR+SC, SR+SC) # initialize adjacency matrix
+   for (i in 1:SR) { # determine which resources each consumer eats: it must eat
+     indices <- sort(c(i, sample((1:SC)[-i], 1))) # the one with
+     w[i+SR,indices] <- 1 # matching trait value, plus a fixed number of
+   } # randomly assigned ones (in this case 4 more, for 5 resources per consumer)
+   omega <- numeric(0) # initialize matrix of consumption efforts
+   rsum <- rowSums(w) # omega[i,j] is the proportion of i's consumption rate,
+   for (i in 1:(SR+SC)) omega <- cbind(omega, rsum) # targeted at consuming j
+   omega[omega!=0] <- 1/omega[omega!=0] # if not 0, set to proportion
+   W <- unname(w*omega) # only the product of w and omega is used
+   return(W)
+ }
> 
> # put the results of the numerical integration into a tidy table
> organize_data <- function(dat, times, pars) {
+   dat <- dat %>%
+     as.data.frame() %>% # convert to data frame (needed for next step)
+     as_tibble() %>% # convert to tibble (tidyverse's improved data frame)
+     filter(time %in% times) # only keep specified time points
+   names(dat)[1] <- "time" # name the first column "time"
+   index <- 2 # keep track of which column we are naming with this counter
+   for (k in 1:pars$L) {
+     for (i in 1:pars$S) { # name columns for densities
+       names(dat)[index] <- paste0("n_", i, "_", k) # naming convention:
+       index <- index + 1 # "type_species_patch" - type is either m (trait),
+     } # or n (density)
+   }
+   for (k in 1:pars$L) {
+     for (i in 1:pars$S) { # name columns for trait values
+       names(dat)[index] <- paste0("m_", i, "_", k) # (same naming convention)
+       index <- index + 1
+     }
+   }
+   dat %>%
+     # normalize table by collapsing columns into a key-value column pair
+     pivot_longer(cols=2:ncol(.), names_to="variable", values_to="v") %>%
+     # split "variable" into value type (density or trait), species, and patch
+     separate(variable, c("type", "species", "patch"), sep="_") %>%
+     # convert species & patch from string ("1","2",...) to integer (1,2,...)
+     mutate(species=as.integer(species), patch=as.integer(patch)) %>%
+     # split trait and abundance values into two columns
+     pivot_wider(names_from="type", values_from="v") %>%
+     # trophic level (tl): species with index greater than SR are consumers ("C"),
+     # the rest are resources ("R")
+     mutate(tl=ifelse(species>SR, "C", "R")) %>%
+     # return tidy table
+     return()
+ }
> 
> 
> # ------------------------------- parameters -----------------------------------
> 
> # number of species and number of patches----
> SR <- S # number of resource species
> SC <- 0 # number of consumer species: 0, unless we have...
> if (model %in% c("trophic", "Tdep_trophic")) SC <- S # ...consumer species
> S <- SR + SC # set S to be the total number of species
> L <- 20 # number of patches
> 
> # scalars----
> set.seed(1000*replicate+325) # set random seed for reproducibility
> v <- runif(SR, 0.25*vbar, 0.25*vbar) # resource genetic variances
> d <- runif(SR, 1*dbar, 1*dbar) # resource dispersal rates
> 
> kappa <- 0.1 # intrinsic mortality parameter
> venv <- vbar # environmental variance
> vmat <- matrix(rep(v, L), S, L) # genetic variances at each patch
> s <- v + venv # species' total phenotypic variances
> eta <- 1 # competition width (centigrade; only for Tdep and Tdep_trophic)
> eps <- c(rep(0, SR), rep(0.3, SC)) # feeding efficiency of consumers
> nmin <- 1e-5 # below this threshold density, genetic variances are reduced
> aw <- 0.1 # (negative) slope of trait-dependence of tolerance width
> bw <- 4 # intercept of trait-dependence of tolerance width
> Tmax <- -60.0 # initial mean temperature at equator
> Tmin <- Tmax # initial mean temperature at poles
> Cmax <- 0 # projected temperature increase at poles
> Cmin <- 0 # projected temperature increase at equator
> tstart <- ts # starting time (relative to start of climate change at t = 0)
> tE <- 2e8 # time at which climate change stops (assuming it starts at t = 0)
> save.image(file = workspace)
> 
> # matrices----
> rho <- runif(SR, 0.9, 1.1) # resource growth-tolerance tradeoff parameter
> a <- matrix(0, S, S) # initialize full competition matrix (resources+consumers)
> # assigned 0.7 & 0.9 instead of 0.5 & 1.5 as margins in aP, to lower competition
> aP <- matrix(runif(SR*SR, 0.15*0.8, 0.15*0.8), SR, SR) # resource comp coeffs
> diag(aP) <- runif(SR, 0.2*0.8, 0.2*0.8) # resource intraspecific comp coeffs
> a[1:SR,1:SR] <- aP # top left block: resources
> W <- matrix(0, S, S) # create feeding network: nothing if no consumers
> Th <- rep(1, S) # handling times in type II f.r. (dummy value if no consumers)
> arate <- rep(1, S) # attack rates in type II f.r. (dummy value if no consumers)
> if (model %in% c("trophic", "Tdep_trophic")) {
+   v <- c(v, runif(SC, 0.5*vbar, 1.5*vbar)) # add consumer genetic variances
+   d <- c(d, runif(SC, 0.1*dbar, 10.0*dbar)) # add consumer dispersal rates
+   rho <- c(rho, runif(SC, 0.9*0.1, 1.1*0.1)) # add consumer tradeoff parameters
+   aH <- matrix(0, SC, SC) # initialize competition matrix (consumers)
+   a[(SR+1):S,(SR+1):S] <- aH # bottom right: consumers
+   W <- generate_network(SR, SC) # trophic feeding network
+   Th[(SR+1):S] <- runif(S-SR, 0.5, 1) # handling times in type II f.r.
+   arate[(SR+1):S] <- runif(S-SR, 1, 10) # attack rates in type II f.r.
+ }
> 
> 
> 
> # dispersal matrix----
> mig <- matrix(0, L, L) # initialize dispersal matrix
> for (k in 2:L) mig[k-1,k] <- 1 # each species can only migrate to the two
> mig <- mig + t(mig) # nearest-neighbor patches
> 
> # initial conditions----
> ninit <- matrix(0, S, L) # reserve memory for initial densities
> muinit <- matrix(seq(Tmin, Tmin, l=SR), SR, L) # initial trait means
> # Edit ! all initial species start with same location controlled de-facto by muninit 
> # initial temperatures
> Tempinit <- Temp(seq(from=0, to=1, l=L), 0, tE, Cmax, Cmin, Tmax, Tmin)
> for (i in 1:SR) ninit[i,] <- exp(-(muinit[i,1]-Tempinit)^2/(2*2^2))
> # initial traits and densities for consumers
> if (model %in% c("trophic", "Tdep_trophic")) {
+   muinit <- rbind(muinit, matrix(seq(Tmin, Tmax, l=SC), SC, L))
+   for (i in (SR+1):S) ninit[i,] <- exp(-(muinit[i,1]-Tempinit)^2/(2*2^2))
+ }
> ic <- c(ninit, muinit) # merge initial conditions into a vector
> 
> # coerce parameters into a list----
> pars <- list(SR=SR, SC=SC, S=S, L=L, rho=rho, kappa=kappa, a=a, eta=eta,
+              eps=eps, W=W, venv=venv, vmat=vmat, s=s, nmin=nmin, aw=aw, bw=bw,
+              Tmax=Tmax, Tmin=Tmin, Th=Th, arate=arate, Cmax=Cmax, Cmin=Cmin,
+              tE=tE, d=d, mig=mig, model=model)
> 
> 
> # --------------------------- integrate ODEs -----------------------------------
> #consider changing rtol and atol
> at <-1e-4
> rt <-1e-4
> before_step <- -tstart/200
> tryCatch({before_cc <-ode(y=ic, times=seq(tstart, 0, by=before_step), func=eqs, parms=pars,
+        method="bdf", atol  = at, rtol = rt, maxsteps = 10000)},
+       error=function(e){message("All Species Extinct")
+                         return(NA)}) # integrate ODEs before climate change starts
> diagnostics(before_cc)

--------------------
lsode return code
--------------------

  return code (idid) =  2 
  Integration was successful.

--------------------
INTEGER values
--------------------

  1 The return code : 2 
  2 The number of steps taken for the problem so far: 309 
  3 The number of function evaluations for the problem so far: 16339 
  5 The method order last used (successfully): 1 
  6 The order of the method to be attempted on the next step: 1 
  7 If return flag =-4,-5: the largest component in error vector 0 
  8 The length of the real work array actually required: 163622 
  9 The length of the integer work array actually required: 420 
 14 The number of Jacobian evaluations and LU decompositions so far: 40 
 
--------------------
RSTATE values
--------------------

  1 The step size in t last used (successfully): 5e+05 
  2 The step size to be attempted on the next step: 5e+05 
  3 The current value of the independent variable which the solver has reached: 333258.3 
  4 Tolerance scale factor > 1.0 computed when requesting too much accuracy: 0 
 
> ic <- as.numeric(before_cc[nrow(before_cc),-1]) # final state -> new initial cond.
> before_cc <- before_cc %>% # put before-climate-change solution into tidy tibble:
+   organize_data(times=seq(from=tstart, to=0, by=before_step), pars = pars) %>%
+   filter(time!=0) # remove time point 0 (will be starting point of during_cc)
> 
> print(Sys.time()-start)
Time difference of 6.710213 secs
> 
> during_step <- tE/200
> at <-1e-5
> rt <-1e-5
> tryCatch({during_cc <-ode(y=ic, times=seq(0, tE, by=during_step), func=eqs, parms=pars,
+       method = "bdf",atol  = at, rtol = rt, maxsteps = 10000)},
+       error=function(e){message("All Species Extinct")
+                         return(NA)},
+       finally = {
+         diagnostics(during_cc)
+         during_cc <- during_cc %>% # put during-climate-change solution into tidy tibble:
+           organize_data(times=seq(from=0, to=tE, by=during_step), pars = pars) #%>%
+         
+         # merge data from before, during, and after climate change
+         dat <- bind_rows(before_cc, during_cc) %>%
+           # add replicate, genetic var., dispersal rate, and structure as new columns
+           mutate(replicate=replicate, vbar=vbar, dbar=dbar, model=model) %>%
+           # merge average genetic variance and dispersal into a single column
+           mutate(parameterization=paste0("V=", vbar, " d=", dbar)) %>%
+           # create regions
+           mutate(region=case_when(
+             (patch<=round(max(patch)/3))   ~ "polar", # top third of patches are "polar"
+             (patch>=round(2*max(patch)/3)) ~ "tropical", # bottom third are "tropical"
+             TRUE                           ~ "temperate")) # the rest are "temperate"
+         
+       })  # integrate from start to end of climate change

--------------------
lsode return code
--------------------

  return code (idid) =  2 
  Integration was successful.

--------------------
INTEGER values
--------------------

  1 The return code : 2 
  2 The number of steps taken for the problem so far: 202 
  3 The number of function evaluations for the problem so far: 4603 
  5 The method order last used (successfully): 1 
  6 The order of the method to be attempted on the next step: 1 
  7 If return flag =-4,-5: the largest component in error vector 0 
  8 The length of the real work array actually required: 163622 
  9 The length of the integer work array actually required: 420 
 14 The number of Jacobian evaluations and LU decompositions so far: 11 
 
--------------------
RSTATE values
--------------------

  1 The step size in t last used (successfully): 1e+06 
  2 The step size to be attempted on the next step: 1e+06 
  3 The current value of the independent variable which the solver has reached: 200006300 
  4 Tolerance scale factor > 1.0 computed when requesting too much accuracy: 0 
 
> # --------------------------- generate output ----------------------------------
> print(tE-max(during_cc$time))
[1] 0
> temp <-(during_cc %>% filter(time %in% c(max(during_cc$time))))
> print(mean(temp$n))
[1] 0.005175679
> #print(min(dat$time[dat$n < 0]))
> if(tE==max(during_cc$time) && mean(temp$n) > 0){ # if ode converged till final time and no significant negative n
+   if (outfile!="") { # if data file to save to was not specified as empty (""):
+     write_csv(dat, path=outfile) }# save data to specified file
+     plot_timeseries(dat %>% filter(time %in% c(tstart, 0, tE)))
+   }
Warning message:
The `path` argument of `write_csv()` is deprecated as of readr 1.4.0.
ℹ Please use the `file` argument instead. 
> print(Sys.time()-start)
Time difference of 8.899868 secs
> 
> 
> proc.time()
   user  system elapsed 
  8.904   0.225   9.031 
